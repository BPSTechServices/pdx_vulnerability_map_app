## Load libraries, set options, source scripts ---------------------------------
library(tidyverse)
library(tidycensus)
library(sf)
library(tigris)
library(furrr)

options(
  scipen = 999,
  digits = 4,
  tigris_class = "sf",
  tigris_use_cache = T
)

## Source script that establishes geographic constants for this application
source("GLOBAL.R")
source("GLOBAL_interpolation_addendum.R") # Addendum to add additional spatial resources
source("3_functions/aggregate_variables.R")

## Load CPI inflation adjustments (CPI-U-RS)
cpi <- rio::import("1_data/0_resources/cpi-u-rs_1950-current.xlsx") %>% 
  select(year, inflation_factor = inflation_factor_2020)

## Download data using multi-threading -----------------------------------------

## Enable multi-core processing
plan(multisession, workers = availableCores())
set.seed(123)

core_tables <- c("B25106", "B03002", "B19013", "B25010", "B15002")

## Grab data for selected years and selected tables
acs_table_query_longitudinal <- future_map_dfr(
  .x = c(2010, 2015, 2020),
  .f = function(acs_year){
    map_dfr(
      .x = core_tables,
      .f = function(acs_table){
        query <- get_acs(geography = "tract",
                         table = acs_table,
                         year = acs_year,
                         state = STATES_TO_DOWNLOAD) %>%
          filter(substr(GEOID, 1, 5) %in% COUNTIES_TO_DOWNLOAD) %>%
          mutate(agg = "count",
                 year = acs_year) %>%
          select(-NAME)
      })
  })

## Determine weighting methods -------------------------------------------------

## Variables that are population-based should be weighted by population
## Variables that are unit-based should be weighted by households
## Variables that are aggregate may need to be re-weighted???
# c("B25106", "B03002", "B19013", "B25010", "B15002")

## Population-based tables: 
# B03002
# B15002

## Unit-based tables: 
# B25010
# B25106
# B19013

## Extensive
# B03002
# B15002
# B25106

## Intensive (extensive == FALSE)
# B25010
# B19013

## Interpolate results ---------------------------------------------------------
## In this section, we interpolate data from 2010 and 2015 to 2020 census tracts.
## Since the use of the weighting variables and the use of extensive/intensive
## weighting mechanisms vary (count data vs aggregate data like medians), we must
## specify the right combination of tables and weighting columns. We do this by
## carefully specifying the list arguments for the pmap() function.

## First we transform our long data to wide data and append spatial data
wide_query <- acs_table_query_longitudinal %>%
  pivot_wider(id_cols = c(GEOID, year), names_from = variable, values_from = estimate) %>%
  left_join(., TRACTS_2010t2020.SF, by = c("GEOID", "year")) %>%
  st_as_sf()

## Set up list arguments for pmap() function
years <- c(rep(2015, 3), 
           rep(2010, 3))

tables <- list(c("B25106"), c("B25010", "B19013"), c("B03002", "B15002"),
               c("B25106"), c("B25010", "B19013"), c("B03002", "B15002"))

weightcols <- c("HOUSING20", "HOUSING20", "POP20",
                "HOUSING20", "HOUSING20", "POP20")

extensives <- c(TRUE, FALSE, TRUE,
                TRUE, FALSE, TRUE)

## Generate list of filtered data based on the years and tables
dfs <- pmap(.l = list(years, tables),
            .f = function(.year, .table){
              # Expand .table in case of multiple tables
              .table <- paste(.table)
              wide_query %>% 
                filter(year == .year) %>% 
                select(GEOID, starts_with(c({{.table}})))
            })

## Interpolate all of the data
interpolated <- future_pmap(
  .l = list(dfs, years, weightcols, extensives), 
  .f = function(.dat, .year, .weightcol, .ext){
    interpolate_pw(from = .dat,
                   to = wide_query %>% 
                     filter(year == 2020) %>% 
                     select(GEOID),
                   to_id = "GEOID",
                   weights = STATE_BLOCKS.2020,
                   weight_column = .weightcol,
                   crs = TARGET_EPSG,
                   extensive = .ext) %>%
      mutate(year = .year) %>%
      relocate(year, .after = GEOID) %>%
      st_drop_geometry()
  },
  .options = furrr_options(seed = TRUE))

## Bind the list together, cast to long format, and standardize the format
## TODO there has to be a more elegant way to do this step...
interpolated.df <- rbind(
  bind_cols(interpolated[1:3], .name_repair = "unique") %>% 
    select(-c(GEOID...49, GEOID...55, year...50, year...56)) %>%
    rename(GEOID = GEOID...1, year = year...2),
  bind_cols(interpolated[4:6], .name_repair = "unique") %>% 
    select(-c(GEOID...49, GEOID...55, year...50, year...56)) %>%
    rename(GEOID = GEOID...1, year = year...2)
) %>%
  pivot_longer(cols = -c(GEOID, year), 
               names_to = "variable", 
               values_to = "estimate") %>%
  mutate(moe = 0,
         agg = "count") %>%
  select(names(acs_table_query_longitudinal))

## Optionally add spatial data and generate a quick map
# interpolated.sf <- interpolated.df %>%
#   left_join(., TRACTS.SF, by = "GEOID") %>%
#   st_as_sf()
#
# interpolated.sf %>% filter(year == 2015, variable == "B25106_001") %>% mapview(zcol = "estimate")

## Aggregate variables ---------------------------------------------------------
## With the data for 2010 and 2015 interpolated to 2020 census tracts, we can 
## perform aggregations on the data after binding it to 2020 datasets

## Create input dataset for the aggregations by rbinding the interpolated dataset to 2020
acs_all_years <- rbind(filter(acs_table_query_longitudinal, year == 2020), interpolated.df)

hcb <- acs_all_years %>% 
  split(.$year) %>%
  map_dfr(.id = "year", 
          .f = ~aggregate_variables(
            long_acs_data = select(.x, -year),
            agg_table = "B25106", varnums = c(6,10,14,18,22,28,32,36,40,44),
            summary_var = "B25106_001", varname = "Housing cost burdened")
  )

poc <- acs_all_years %>% 
  split(.$year) %>%
  map_dfr(.id = "year", 
          .f = ~aggregate_variables(
            long_acs_data = select(.x, -year),
            agg_table = "B03002", varnums = c(4:9,12),
            summary_var = "B03002_001", varname = "People of color")
  )

bna <- acs_all_years %>% 
  split(.$year) %>%
  map_dfr(.id = "year", 
          .f = ~aggregate_variables(
            long_acs_data = select(.x, -year),
            agg_table = "B03002", varnums = c(4,5,14,15),
            summary_var = "B03002_001", varname = "Black + Native American")
  )

no4yr <- acs_all_years %>% 
  split(.$year) %>%
  map_dfr(.id = "year", 
          .f = ~aggregate_variables(
            long_acs_data = select(.x, -year),
            agg_table = "B15002", varnums = c(3:14, 20:31),
            summary_var = "B15002_001", varname = "Adults without 4-yr degree")
  )

# Special case -- change it for formatting and adjust for inflation
mhi <- acs_all_years %>% 
  filter(variable == "B19013_001") %>%
  mutate(agg = "median", variable = "Median household income",
         table = "B19013", varnum = 1) %>%
  left_join(., cpi, by = "year") %>%
  mutate(across(c(estimate, moe), ~ . * inflation_factor)) %>%
  select(-inflation_factor)

# Special case -- just change it for formatting
hhsize <- acs_all_years %>% 
  filter(variable == "B25010_001") %>%
  mutate(agg = "aggregate", variable = "Average household size",
         table = "B25010", varnum = 1) 

## Combine all the aggregated data together
acs_data_aggregated <- rbind(hcb, poc, bna, no4yr, mhi, hhsize)
saveRDS(acs_data_aggregated, "1_data/2_interim/acs_data_aggregated_interpolated.rds")


## Cast and reformat data ------------------------------------------------------

## Wide data to be used in the shiny app
wide_data <- acs_data_aggregated %>%
  filter(agg %in% c("percent", "median", "aggregate")) %>%
  select(GEOID, year, agg, variable, E = estimate) %>% 
  pivot_wider(id_cols = c(GEOID, year), names_from = variable, values_from = c(E)) %>% 
  left_join(., TRACTS.SF, by = "GEOID") %>% 
  janitor::clean_names() %>% rename(GEOID = geoid) %>%
  select(everything(), county = namelsadco, -c(statefp:stusps, state_name:awater)) %>%
  mutate(county = str_replace(county, " County", " Co."),
         housing_cost_burdened = ifelse(is.na(housing_cost_burdened), 0, housing_cost_burdened),
         adjusted_household_income = median_household_income / average_household_size ^ 0.5) %>%
  select(GEOID, year, people_of_color, black_native_american, adults_without_4_yr_degree,
         housing_cost_burdened, median_household_income, adjusted_household_income, 
         average_household_size, county, in_primary_place, geometry) %>%
  st_as_sf()

saveRDS(wide_data, "1_data/3_processed/acs_vuln_weighting_data_interpolated.rds")



# saveRDS(changes, "1_data/3_processed/2010t2020_change_summary")


changes %>%
  filter(
    agg == "median",
    variable == "Adjusted household income",
    in_primary_place == TRUE) %>%
  mapview(zcol = "pct_change_10t20")








## ARCHIVE -- OLD CODE ---------------------------------------------------------

## For the app, transform the long data to wide format and export
# wide_data <- acs_allocation_to_2020_tracts %>%
#   st_drop_geometry() %>%
#   filter(agg %in% c("percent", "median", "aggregate")) %>%
#   select(GEOID, year, agg, variable, E = estimate) %>% #, M = moe) %>%
#   pivot_wider(id_cols = c(GEOID, year), names_from = variable, values_from = c(E)) %>%
#   janitor::clean_names() %>% rename(GEOID = geoid) #%>%
# select(everything(), county = NAMELSADCO, -c(STATEFP:STUSPS, STATE_NAME:AWATER)) %>%
# mutate(county = str_replace(county, " County", " Co."),
#        housing_cost_burdened = ifelse(is.na(housing_cost_burdened), 0, housing_cost_burdened),
#        adjusted_household_income = median_household_income / average_household_size ^ 0.5) %>%
# select(GEOID, people_of_color, black_native_american, adults_without_4_yr_degree, 
#        adjusted_household_income, housing_cost_burdened, average_household_size,  
#        county, in_primary_place, geometry)

## alternate code july 18 807am

# tmp <- acs_data_aggregated %>%
#   filter(agg == "count") %>%
#   pivot_wider(id_cols = c(GEOID, year), 
#               names_from = variable, 
#               values_from = c(estimate)) %>%
#   janitor::clean_names() %>% rename(GEOID = geoid) %>%
#   mutate(year = as.numeric(year)) %>%
#   left_join(., TRACTS_2010t2020.SF, by = c("GEOID", "year")) %>%
#   st_as_sf()

## This appears to work. Try to transform all of my variables into wide format
## and run the code again. by "all variables" I mean the raw acs query
# tmp2 <- interpolate_pw(
#   from = tmp %>% filter(year == 2015) %>% select(-year),
#   to = tmp %>% filter(year == 2020),
#   to_id = "GEOID",
#   weights = STATE_BLOCKS.2020,
#   weight_column = "HOUSING20",
#   crs = TARGET_EPSG,
#   extensive = TRUE)



## Determine weighting methods -------------------------------------------------
## Variables that are population-based should be weighted by population
## Variables that are unit-based should be weighted by households
## Variables that are aggregate may need to be re-weighted???
# c("B25106", "B03002", "B19013", "B25010", "B15002")

## Population-based tables: 
# B03002
# B15002

## Unit-based tables: 
# B25010
# B25106
# B19013

## Extensive
# B03002
# B15002
# B25106

## Intensive (extensive == FALSE)
# B25010
# B19013

## Interpolate results ---------------------------------------------------------

## Prep data for pw_interpolate by specifying extensive and weight columns based
## off the kinds of variables
pw_acs_prep <- acs_data_aggregated %>%
  mutate(extensive = ifelse(table %in% c("B03002", "B15002", "B25106"), TRUE, FALSE),
         extensive = ifelse(agg == "percent", FALSE, extensive),
         weight_column = ifelse(table %in% c("B03002", "B15002"), "POP20", "HOUSING20"),
         group = paste(extensive, weight_column, variable, sep = "_"),
         year = as.numeric(year)) %>%
  left_join(., TRACTS_2010t2020.SF, by = c("GEOID", "year")) %>%
  st_as_sf() 


## Call names to determine the order of the extensive/weights in order to feed
## it into the pmap() function below.
# acs_groups <- split(pw_acs_prep, pw_acs_prep$group)
# names(acs_groups)
# 
# extensives <- c(
#   rep(FALSE, 6), 
#   rep(TRUE, 4))
# 
# weights <- c(
#   rep("HOUSING20", 3),
#   rep("POP20", 3),
#   "HOUSING20",
#   rep("POP20", 3))
# 
# years <- c(rep(2015,10), rep(2010,10))
# 
# ## Apply population-weighted interpolation across the grouped ACS data using a 
# ## pmap function. Be sure to append the aggregation type (pct vs count, etc.)
# acs.pw <- future_pmap(.l = list(rep(acs_groups,2), 
#                                 rep(extensives,2), 
#                                 rep(weights,2),
#                                 years),
#                       .f = function(.x, ext, wgt, allocation_year){
#                         interpolate_pw(
#                           from = .x %>% filter(year == allocation_year) %>% select(estimate),
#                           to = .x %>% filter(year == 2020),
#                           to_id = "GEOID",
#                           weights = STATE_BLOCKS.2020,
#                           weight_column = wgt,
#                           crs = TARGET_EPSG,
#                           extensive = ext) %>%
#                           mutate(agg = .x$agg[[1]],
#                                  year = allocation_year)
#                       },
#                       .options = furrr_options(seed = TRUE))
# 
# ## Clean up interpolated data for 2015 data allocated to 2020 tracts
# acs_allocation_to_2020_tracts <- acs.pw %>% 
#   enframe() %>%
#   unnest(cols = c(value)) %>%
#   separate(name, into = c("extensive", "weight", "variable"), sep = "_") %>%
#   relocate(GEOID, year, variable, agg, estimate, .before = extensive) %>%
#   st_as_sf()
# 
# ## Quick map of the data
# acs_allocation_to_2020_tracts %>%
#   filter(year == 2010, 
#          variable == "Median household income") %>%
#   mapview(zcol = "estimate") 
# 
# ## Subset 2020 and match schema to new allocation data
# acs2020_selection <- acs_data_aggregated %>%
#   filter(year == 2020) %>%
#   mutate(extensive = NA_character_, weight = NA_character_, year = as.numeric(year)) %>%
#   left_join(., TRACTS_2010t2020.SF, by = c("GEOID", "year")) %>%
#   st_as_sf() %>%
#   select(names(acs_allocation_to_2020_tracts))
# 
# ## Bind 2020 data to allocation data and calculate change between years
# acs_allocation_to_2020_tracts %>%
#   rbind(acs2020_selection, .) %>%
#   group_by(GEOID, agg, variable) %>%
#   mutate(change_10t20 = estimate[year == 2020] - estimate[year == 2010],
#          change_15t20 = estimate[year == 2020] - estimate[year == 2015]) %>%
#   ungroup() %>%
#   filter(year == 2020,
#          variable == "Housing cost burdened",
#          agg == "percent") %>%
#   mapview(zcol = "change_15t20")
# 
# ## Transform data --------------------------------------------------------------
# ## For the app, transform the long data to wide format and export
# wide_data <- acs_allocation_to_2020_tracts %>%
#   st_drop_geometry() %>%
#   filter(agg %in% c("percent", "median", "aggregate")) %>%
#   select(GEOID, year, agg, variable, E = estimate) %>% #, M = moe) %>%
#   pivot_wider(id_cols = c(GEOID, year), names_from = variable, values_from = c(E)) %>%
#   janitor::clean_names() %>% rename(GEOID = geoid) #%>%
# 
# 





