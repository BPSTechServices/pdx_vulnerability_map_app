# Must first run 5_apps/weighting_tool/00_prep_app.R to generate imputed data
source("GLOBAL.R")
range01 <- function(x, ...){(x - min(x, ...)) / (max(x, ...) - min(x, ...))}

imputed_data <- readRDS("5_apps/weighting_tool/acs_vuln_weighting_data.rds")

## Create working dataset of variables we wish to create yes/no flags for
vars_to_flag <- imputed_data %>%
  st_drop_geometry() %>%
  select(GEOID, in_primary_place, people_of_color, black_native_american, 
         adults_without_4_yr_degree, adjusted_household_income, housing_cost_burdened, 
         households_with_limited_english, persons_with_disabilities, 
         retirees_65, youth_0_21) 

## Generate the yes/no flags based on percentile rank of .6 or more
flagged_tracts <- vars_to_flag %>%
  pivot_longer(-c(GEOID, in_primary_place), 
               names_to = "variable", values_to = "estimate") %>%
  filter(in_primary_place) %>%
  group_by(variable) %>%
  mutate(higher_proportion = ifelse(cume_dist(estimate) >= 0.6, TRUE, FALSE)) %>%
  ungroup() %>%
  select(GEOID, variable, higher_proportion) %>%
  pivot_wider(names_from = c(variable), values_from = c(higher_proportion), 
              names_prefix = "hi_")

## Separate task: generate hatch overlays for select variables and save individually as RDS files
hatch_vars <- c("people_of_color", "households_with_limited_english", "persons_with_disabilities", "retirees_65", "youth_0_21")

map(hatch_vars, function(hatch_var){
  imputed_data %>%
    filter(in_primary_place) %>%
    mutate(flag_hatch = ifelse(cume_dist(.data[[hatch_var]]) >= 0.6, TRUE, FALSE)) %>%
    filter(flag_hatch) %>%
    HatchedPolygons::hatched.SpatialPolygons(., density = 400, angle = 45) %>% ## spatial projection matters for density argument
    mutate(col = 1,
           hatch_var = hatch_var) %>%
    saveRDS(paste0("5_apps/weighting_tool/hatch_", hatch_var, ".rds"))
})

## Generate a vulnerability score based off the desired methodology
vulnerability_results <- imputed_data %>%
  filter(in_primary_place) %>%
  mutate(across(.cols = c(people_of_color:youth_and_retirees), 
                .fns = list(rnk = ~cume_dist(.),
                            z = ~scale(.))),
         across(ends_with("_z"), ~ case_when(. > 3 ~ 3,
                                             . < -3 ~ -3,
                                             T ~ .)),
         adjusted_household_income_rnk = 1 - adjusted_household_income_rnk,
         adjusted_household_income_z = -adjusted_household_income_z,
         
         composite_score = people_of_color_rnk + black_native_american_rnk + 
           adjusted_household_income_rnk + housing_cost_burdened_rnk + 
           adults_without_4_yr_degree_rnk,
         
         indexed_score = round(range01(composite_score, na.rm = T) * 100, 0),
         flag_vulnerable = ifelse(indexed_score >= 60, TRUE, FALSE)) 

## Save the vulnerability results as a hatch overlay RDS file
vulnerability_results %>%
  filter(flag_vulnerable) %>%
  HatchedPolygons::hatched.SpatialPolygons(., density = 400, angle = 135) %>% ## spatial projection matters for density argument
  mutate(col = 1,
         hatch_var = "vulnerable") %>%
  saveRDS("5_apps/weighting_tool/hatch_vulnerable.rds")

## Create new vulnerability data based on methodology and include the yes/no overlays
## generated in the first step above. Save as GEOJSON and as an XLSX file
vulnerability_data <- vulnerability_results %>%
  select(GEOID, vulnerability_score = indexed_score, flag_vulnerable) %>%
  left_join(., select(vars_to_flag, -in_primary_place), by = "GEOID") %>%
  left_join(., flagged_tracts, by = "GEOID") %>%
  relocate(-geometry) %>%
  st_drop_geometry() %>%
  left_join(., TRACTS_HIRES.SF %>% select(GEOID)) %>%
  st_as_sf() %>% st_transform(TARGET_EPSG) 

st_write(vulnerability_data, dsn = "1_data/3_processed/2020_vulnerability_data_portland.geojson")
vulnerability_data %>%
  st_drop_geometry() %>% rio::export("1_data/3_processed/2020_vulnerability_data_portland.xlsx")
